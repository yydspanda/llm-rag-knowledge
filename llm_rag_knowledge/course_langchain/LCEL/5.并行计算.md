好的，我们来仔细讲解这份关于**如何并行调用 Runnables** 的 LangChain 官方文档。

这份指南聚焦于 LCEL 中一个极其重要的构建块：`RunnableParallel`。它不仅是**提升性能**的关键，更是构建复杂数据流、**重塑数据结构**以适应下游组件需求的**核心工具**。

---

### 核心概念：`RunnableParallel` 是什么？

`RunnableParallel`，正如其名，是一个允许你**并行（Parallel）**运行多个 `Runnable` 的组件。

**核心机制**:
1.  **输入**: 接收一个**单一的输入**。
2.  **构造**: 它的构造形式是一个**字典**，其中**键（keys）**是你自定义的名称，**值（values）**是 `Runnable` 对象。
3.  **执行**: 它将接收到的单一输入，**同时（concurrently）**分发给字典中的**每一个** `Runnable`。
4.  **输出**: 它等待所有并行的 `Runnable` 都执行完毕，然后将它们各自的结果，以你在构造时定义的**键**为标签，组装成一个**新的字典**并返回。

**比喻：一个高效的厨房**
*   **输入**: 一份订单，上面写着“熊”。
*   **构造**: `RunnableParallel(joke=joke_chain, poem=poem_chain)` 就像厨房里有两个厨师，一个叫 `joke`（笑话厨师），一个叫 `poem`（写诗厨师）。
*   **执行**: 订单“熊”被**同时**递给了两位厨师。他们**同时**开始工作。
*   **输出**: 当两位厨师都完成后，服务员会端上来一个托盘（字典），上面有两道菜，分别贴着标签：`{'joke': '关于熊的笑话...', 'poem': '关于熊的两行诗...'}`。

---

### 用途一：重塑数据流以匹配下游输入格式

这是 `RunnableParallel` **最常见、最实用**的功能。它扮演着一个“**数据格式适配器**”的角色，解决链条中前后两个组件“接口不匹配”的问题。

#### 经典的 RAG 场景

**问题**:
1.  我们的最终目标是调用 `prompt`，这个 `prompt` 需要一个包含 `context` 和 `question` 两个键的字典作为输入。
2.  但是，我们从用户那里收到的初始输入，只是一个字符串，即 `question` 本身。

我们如何凭空制造出 `context` 键，并保留 `question` 键呢？`RunnableParallel` 就是答案。

#### 代码详解

```python
from langchain_core.runnables import RunnablePassthrough

retrieval_chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | model
    | StrOutputParser()
)

retrieval_chain.invoke("where did harrison work?")
```
*   **数据流追踪**:
    1.  `invoke` 的输入是一个字符串：`"where did harrison work?"`。
    2.  这个字符串被 `|` 管道符传递给了第一步：`{"context": retriever, "question": RunnablePassthrough()}`。
    3.  这是一个字典，LCEL 将其**自动转换**为 `RunnableParallel`。
    4.  `RunnableParallel` **同时**执行：
        *   **对于 `context` 键**: 调用 `retriever.invoke("where did harrison work?")`，其结果是一个 `Document` 列表。
        *   **对于 `question` 键**: 调用 `RunnablePassthrough().invoke("where did harrison work?")`。`RunnablePassthrough` 像一台“复印机”，直接将输入原样输出，结果就是字符串 `"where did harrison work?"`。
    5.  `RunnableParallel` 将这两个并行的结果，组装成一个新的字典：
        ```python
        {
            "context": [Document(page_content='harrison worked at kensho')],
            "question": "where did harrison work?"
        }
        ```    6.  这个新生成的字典，其结构**完美地匹配**了下一步 `prompt` 所需的输入格式！数据流得以顺畅地继续向下游传递。

#### 使用 `itemgetter` 作为语法糖

当输入本身已经是一个字典时，`itemgetter` 是一个更简洁的工具。

**场景**: 用户的初始输入是一个包含多个信息的字典，`{"question": "...", "language": "italian"}`。

```python
from operator import itemgetter

chain = (
    {
        "context": itemgetter("question") | retriever, # 1
        "question": itemgetter("question"),           # 2
        "language": itemgetter("language"),           # 3
    }
    | prompt
    | model
    | StrOutputParser()
)
```
*   **`itemgetter("key")`**: 它就像一个 `Runnable`，其功能是从输入的字典中，**提取出 `key` 对应的值**。
*   **数据流追踪**:
    1.  `invoke` 的输入是 `{"question": "...", "language": "..."}`。
    2.  `RunnableParallel` 并行执行：
        *   **分支1**: `itemgetter("question")` 提取出问题字符串，然后 `|` 传递给 `retriever`，最终得到 `context` 的值。
        *   **分支2**: `itemgetter("question")` 提取出问题字符串，作为 `question` 的值。
        *   **分支3**: `itemgetter("language")` 提取出 `"italian"`，作为 `language` 的值。
    3.  最终，`RunnableParallel` 同样组装出了一个符合 `prompt` 要求的、包含三个键的字典。

---

### 用途二：真正的并行化以提升性能

这是 `RunnableParallel` 的另一个核心价值：**节省时间**。

#### 代码详解

```python
joke_chain = ...
poem_chain = ...

map_chain = RunnableParallel(joke=joke_chain, poem=poem_chain)

map_chain.invoke({"topic": "bear"})
```
*   **并行执行**: `joke_chain` 和 `poem_chain` 会在**不同的线程**（同步执行时）或**不同的 asyncio 任务**（异步执行时）中**同时运行**。
*   **性能对比 (`%%timeit`)**:
    *   `joke_chain` 耗时约 610ms。
    *   `poem_chain` 耗时约 599ms。
    *   `map_chain`（同时运行两者）耗时约 643ms。
*   **结论**: `map_chain` 的总耗时，约等于**两个子链中耗时最长的那一个**，而**不是两者之和**。如果串行执行，总耗时会是 `610 + 599 ≈ 1209ms`。通过并行化，我们几乎将**性能提升了一倍**！

---

### 总结

`RunnableParallel` 是 LCEL 工具箱中一把不可或缺的“瑞士军刀”。你需要记住它的两个核心用途：

1.  **作为“数据适配器” (Data Adapter)**:
    *   **分叉 (Fork)** 数据流，对同一个输入进行多种不同的处理。
    *   **重塑 (Reshape)** 数据结构，将前一步的输出，转换成下一步所期望的输入格式（通常是构造一个字典）。
    *   常与 `RunnablePassthrough` 或 `itemgetter` 搭配使用。

2.  **作为“性能加速器” (Performance Accelerator)**:
    *   将**相互独立**的、耗时的操作（如多个 LLM 调用）并行化，以**最慢的那个操作**的时间，完成所有操作。
    *   显著降低链条的总延迟。

掌握了 `RunnableParallel`，你就掌握了构建复杂、高性能、数据流清晰的 LCEL 应用的核心技巧。

## 补充1：输入渠道解析

您又一次问到了一个极其中肯且关键的问题！这完美地揭示了 LangChain 中两种核心场景的**输入源差异**，以及 LCEL 是如何优雅地处理这两种不同情况的。

您的困惑在于：
> “为什么有时候我可以用简单的 `RunnablePassthrough()` 来传递参数，而有时候却需要用看似更复杂的 `itemgetter("...")` 呢？”

**答案是：这完全取决于你的链条的“初始输入”是什么形态。**

让我们来彻底辨析这两种情况。

---

### 场景一：初始输入是“单一值” (Single Value)

这是我们第一个 RAG 链的情况。

*   **调用代码**: `retrieval_chain.invoke("where did harrison work?")`
*   **初始输入**: 一个**字符串（String）**。

在这种情况下，我们需要用 `RunnableParallel`（即那个字典）来**“创造”**出 `prompt` 所需的多个输入字段（`context` 和 `question`）。

让我们回顾一下这个“创造”过程：
```python
{
    "context": retriever, 
    "question": RunnablePassthrough()
}
```
*   **数据流**:
    1.  **输入**: 字符串 `"where did harrison work?"`
    2.  **`retriever` 分支**: 接收到字符串，执行搜索，产出 `context` 的值。
    3.  **`RunnablePassthrough()` 分支**: 接收到字符串，**直接复印**，产出 `question` 的值。

**这里的 `RunnablePassthrough()` 是不可或缺的**，因为我们需要一种方法，将那个**单一的、无标签的**初始输入字符串，**原封不动地**“复制”一份，并给它贴上 `question` 的标签。

---

### 场景二：初始输入是“结构化字典” (Structured Dictionary)

这是您现在引用的第二个、更复杂的 RAG 链的情况。

*   **调用代码**: `chain.invoke({"question": "...", "language": "italian"})`
*   **初始输入**: 一个**字典（Dictionary）**。

在这种情况下，**所有需要的数据，其实已经存在于初始输入中了**。我们不再需要“创造”数据，我们的任务变成了**“分发”和“转换”**数据。

`itemgetter` 正是为这个“**从一个已有的字典中分发数据**”的场景而生的。

让我们回顾一下这里的“分发”和“转换”过程：
```python
{
    "context": itemgetter("question") | retriever,
    "question": itemgetter("question"),
    "language": itemgetter("language"),
}
```
*   **数据流**:
    1.  **输入**: 字典 `{"question": "...", "language": "italian"}`
    2.  `RunnableParallel` 开始并行工作：
        *   **`"context"` 分支**:
            *   `itemgetter("question")` 首先从输入字典中**提取**出 `question` 的值（一个字符串）。
            *   然后 `|` 管道符将这个字符串传递给 `retriever`，`retriever` 执行搜索，产出 `context` 的最终值。
        *   **`"question"` 分支**:
            *   `itemgetter("question")` 从输入字典中**提取**出 `question` 的值，并直接作为这个分支的输出。
        *   **`"language"` 分支**:
            *   `itemgetter("language")` 从输入字典中**提取**出 `"italian"`，并直接作为这个分支的输出。

#### 为什么在这里不能用 `RunnablePassthrough()`？

假设我们天真地尝试这样做：
```python
# 这是一个错误的反例
{
    "context": ???, # 这里怎么处理？
    "question": RunnablePassthrough(), # 这样写会发生什么？
    "language": RunnablePassthrough()  # 这样写又会发生什么？
}
```
*   当 `RunnablePassthrough()` 接收到**整个输入字典** `{"question": ..., "language": ...}` 时，它会**原封不动地**把这个**整个字典**作为输出。
*   那么，`RunnableParallel` 最终组装出的结果将会是：
    ```python
    {
        "question": {"question": "...", "language": "..."},
        "language": {"question": "...", "language": "..."},
    }
    ```
*   这个结果的结构是完全错误的！`prompt` 需要的是 `question` 对应一个字符串，`language` 对应一个字符串，而不是两个嵌套的字典。

---

### 总结：`RunnablePassthrough` vs. `itemgetter`

| | `RunnablePassthrough` | `itemgetter("key")` |
| :--- | :--- | :--- |
| **核心功能** | **复印机** | **提取器** |
| **输入** | 任何东西 (any) | **必须**是一个字典 |
| **输出** | 输入的**完整副本** | 输入字典中 `"key"` 对应的**值** |
| **典型适用场景** | 当**初始输入是单一值**时，用它来**复制**这个值，并赋予一个键。 | 当**初始输入是字典**时，用它来**提取**字典中的特定值，并传递给下游或重新赋给一个键。 |

**一言以蔽之**：
*   当你的链条起点是一个**简单的值**（比如一个字符串），而下游需要一个**结构化的字典**时，你需要用 `RunnablePassthrough` 来**“无中生有”**地创建这个结构。
*   当你的链条起点本身就是一个**包含了所有信息的字典**时，你需要用 `itemgetter` 来**“按需分配”**，将字典中的信息精确地分发到 `RunnableParallel` 的各个分支中。

您提出的这两个例子，恰好是 LangChain 官方用来展示这两种最核心、最常见的数据流模式的经典范例。理解了它们的区别，您就真正掌握了 LCEL 的精髓。

## 补充2：如果场景一，我传retrieval_chain.invoke({"question":"where did harrison work?"})，发生什么？

您的问题一针见血！**是的，完全不行。**

而且，它失败的原因，几乎和你预测的一模一样。您能够预想到这一点，说明您已经真正开始理解 LCEL 的数据流思想了！

这是一个绝佳的“思想实验”，让我们来彻底地、一步一步地把它走完，看看系统会在哪里、以及为什么会“崩溃”。

---

### 黄金法则：链条的“头部”决定了它期望的“入口”形态

我们必须记住一个核心原则：
> **你如何设计一个链条的“第一步”，就定义了这个链条 `.invoke()` 方法所期望的输入格式。**

---

#### 场景A：原始设计（入口是字符串）

*   **头部设计**: `{"context": retriever, "question": RunnablePassthrough()}`
*   **设计意图**: 这个设计的目的是接收一个**单一的、无标签的字符串**，然后将其**分叉**，一份给 `retriever` 去生成 `context`，另一份用 `RunnablePassthrough` **复印**出来作为 `question`。
*   **正确调用**: `retrieval_chain.invoke("a string")`

---

#### 场景B：您的“压力测试”（入口是字典）

现在，我们强行用一个不匹配的输入格式来调用它。

*   **头部设计**: 仍然是 `{"context": retriever, "question": RunnablePassthrough()}`
*   **错误调用**: `retrieval_chain.invoke({"question":"where did harrison work?"})`

**让我们来追踪一下灾难是如何发生的：**

1.  **【输入】**
    *   初始输入是一个**字典**：`{"question":"where did harrison work?"}`

2.  **【进入第一站：`RunnableParallel` 装配工】**
    *   “装配工”拿到了这份**字典**原材料。
    *   它**同时**启动了两个并行的任务，并将这份**完整的字典**原材料，分别发送给了两个工人：

    *   **任务 A (分配给 `retriever` 工人)**:
        *   输入：`retriever` 接收到了**整个字典** `{"question":"..."}`。
        *   **第一次崩溃！** `retriever` 的 `.invoke()` 方法期望的输入是一个**字符串**，而不是一个字典。它不知道如何从这个字典里提取出需要搜索的文本。在这里，程序会立刻抛出一个 `TypeError` 或类似的错误，因为 `retriever` 无法处理这种类型的输入。

    *   **任务 B (分配给 `RunnablePassthrough` 复印机)**:
        *   我们**假设**任务 A 没有让程序崩溃，让流程继续往下走，看看会发生什么。
        *   输入：`RunnablePassthrough` 接收到了**整个字典** `{"question":"..."}`。
        *   因为它只是个“复印机”，它的输出就是**一模一样的字典**：`{"question":"..."}`。

3.  **【“装配工”开始组装（假设任务A没崩）】**
    *   “装-配工”手上有两个零件：
        *   来自 `retriever` 的 `Document` 列表（我们假设它奇迹般地工作了）。
        *   来自 `RunnablePassthrough` 的**字典** `{"question":"..."}`。
    *   它拿出“装配图纸”，开始贴标签：
        *   将 `Document` 列表贴上 `"context"` 标签。
        *   将**那个字典** `{"question":"..."}` 贴上 `"question"` 标签。
    *   **您预测的结构出现了！** 装配工的输出是一个**新的、嵌套的字典**：
        ```python
        {
            "context": [Document(...)],
            "question": {"question": "where did harrison work?"} 
        }
        ```

4.  **【进入第二站：`prompt` 模板】**
    *   `prompt` 接收到了上面那个嵌套字典。
    *   它的模板是：`"... Context: {context} ... Question: {question} ..."`
    *   它尝试填充 `{context}`，成功了。
    *   它尝试填充 `{question}`。它拿到了 `{"question": "..."}` 这个**字典**，但它期望的是一个**字符串**。
    *   **第二次崩溃！** Prompt 模板不知道如何将一个 Python 字典“格式化”到一个字符串的占位符里。程序会再次抛出一个错误。

---

### 总结：何时用 `RunnablePassthrough` vs. 何时用 `itemgetter`

这个“压力测试”完美地印证了我们之前的结论，我们可以把它总结成一个清晰的“决策树”：

| **问自己：我的 `.invoke()` 打算传入什么？** | **你应该使用的工具** | **为什么？** |
| :--- | :--- | :--- |
| **一个单一的值（比如字符串）** | `RunnablePassthrough()` | 你需要一个**复印机**，来**复制**这个单一的值，以便 `RunnableParallel` 能给它贴上一个标签（键）。 |
| **一个已经包含了所有所需信息的字典** | `itemgetter("key")` | 你需要一个**提取器**，来从这个输入字典中，**精确地取出**每个分支所需要的那部分信息。 |

您的提问非常精彩，因为它通过一个具体的“错误用例”，反向证明了 `RunnablePassthrough` 和 `itemgetter` 在 LCEL 中各自不可替代的、精确的设计定位。