[参考链接](https://python.langchain.com/docs/how_to/configure/)

好的，我们来仔细讲解这份关于**如何在运行时配置链（Chain）内部组件**的 LangChain 官方文档。

这份指南介绍的是 LCEL 中两个极其强大的**高级配置**功能：`configurable_fields` 和 `configurable_alternatives`。掌握它们，意味着你将从一个只能构建**静态链**的开发者，升级为一个能够构建**动态的、可实验的、甚至可供最终用户定制**的 AI 应用/平台的架构师。

---

### 核心问题：为什么需要“运行时配置”？

在简单的链中，我们通常在代码中就写死了所有配置（比如 LLM 的 `temperature=0`，或者固定使用某个 Prompt）。但当应用变得复杂时，这种**静态绑定**会带来很多问题：

1.  **A/B 测试困难**：如果你想测试 `temperature=0` 和 `temperature=0.9` 哪个效果更好，你可能需要部署两个版本的应用。
2.  **多租户/个性化需求**：用户 A 可能喜欢简洁的回答，用户 B 可能喜欢详细的回答。你无法为每个用户都写一套不同的链。
3.  **模型切换不便**：如果你想从 OpenAI 的 `gpt-4o-mini` 切换到 Anthropic 的 `claude-3-haiku` 来对比成本和性能，你需要修改代码并重新部署。

“运行时配置”就是为了解决这些问题而生的。它提供了一种机制，让你可以在**不修改代码**的情况下，仅仅通过在调用（`.invoke()`）时传入一个 `config` 字典，就能**动态地改变链内部组件的行为**。

---

### 方案一：`configurable_fields` —— 动态调校“参数”

这是两种方法中更简单的一种。

**核心思想**:
> 允许你在运行时，**修改**一个 `Runnable` 对象的**某个特定属性（Field）**的值。

**比喻：一个带“专业模式”的相机**
*   你的相机（`Runnable`）有一个默认的 `temperature` 设置。
*   `configurable_fields` 相当于在相机上开放了一个“**专业接口**”。
*   在拍照时（调用 `.invoke()`），你可以通过这个接口，临时地告诉相机：“这次拍照，请把 `temperature` 调到 `0.9`。”
*   这次拍照完成后，相机**恢复默认设置**。

#### 代码详解

**1. 定义可配置字段**
```python
from langchain_core.runnables import ConfigurableField

model = ChatOpenAI(temperature=0).configurable_fields(
    temperature=ConfigurableField(
        id="llm_temperature", # 这是一个全局唯一的ID，用于在config中引用
        name="LLM Temperature", # 这是给用户看的友好名称（用于UI）
        description="The temperature of the LLM", # 描述
    )
)
```
*   `.configurable_fields()`: 这个方法将一个普通的 `Runnable` 变成了一个“可配置”的 `Runnable`。
*   `temperature=...`: 我们声明 `ChatOpenAI` 的 `temperature` 属性是可配置的。
*   `ConfigurableField(...)`: 我们为这个可配置的属性定义了一个“接口”，最重要的是 `id`。

**2. 在运行时配置**

```python
# 使用默认的 temperature=0
model.invoke("pick a random number") # -> 可能总是返回 '17'

# 在调用时，通过 config 字典动态修改
model.with_config(
    configurable={"llm_temperature": 0.9}
).invoke("pick a random number") # -> 每次都可能返回不同的数字，比如 '12', '35'
```
*   
* **`.with_config()`**: 这是触发配置的入口。
*   **`configurable={...}`**: 这是一个特殊的字典，专门用来存放运行时配置。
*   **`"llm_temperature": 0.9`**: 我们使用之前定义的 `id` (`"llm_temperature"`) 作为**键**，来指定我们要修改哪个字段，并提供新的值 `0.9`。

**关键点**：这个配置可以作用于整个链。当你在一个 `chain` 上调用 `.with_config(...)` 时，LangChain 会自动将配置应用到链中所有声明了相应 `ConfigurableField` 的组件上。

---

### 方案二：`configurable_alternatives` —— 动态替换“整个组件”

这是更强大、更具颠覆性的配置方法。

**核心思想**:
> 允许你在运行时，将链中的**某一个 `Runnable` 组件，完整地替换成另一个备选的 `Runnable`**。

**比喻：一个带“可换镜头”的相机**
*   你的链（相机）默认安装了一个**标准镜头**（默认的 `Runnable`，比如 `ChatAnthropic`）。
*   `configurable_alternatives` 相当于给这个相机增加了一个**卡口（Mount）**，并告诉你这个卡口上还可以安装“**广角镜头**”（`ChatOpenAI`）和“**长焦镜头**”（`ChatOpenAI(model="gpt-4")`）。
*   在拍照时，你可以通过配置，告诉相机：“这次拍照，请换上‘广角镜头’。”

#### 代码详解

**1. 定义可替换的“槽位”和备选项**
```python
from langchain_anthropic import ChatAnthropic

llm = ChatAnthropic(
    model="claude-3-haiku-20240307", temperature=0
).configurable_alternatives(
    # 1. 定义这个“可替换槽位”的ID
    ConfigurableField(id="llm"),
    # 2. 指定默认使用哪个选项的“键名”
    default_key="anthropic",
    # 3. 提供备选项，格式为 "键名"=Runnable对象
    openai=ChatOpenAI(),
    gpt4=ChatOpenAI(model="gpt-4"),
)

chain = prompt | llm
```
*   `.configurable_alternatives()`: 这个方法将一个 `Runnable` 变成了一个“可替换”的 `Runnable`。
*   `ConfigurableField(id="llm")`: 我们声明了一个 ID 为 `"llm"` 的**可替换槽位**。
*   `default_key="anthropic"`: 我们并没有定义一个叫 `"anthropic"` 的备选项。这个 `default_key` 指的是**原始的 `Runnable` 对象本身**（即那个 `ChatAnthropic` 实例）。
*   `openai=ChatOpenAI()`: 我们提供了一个名为 `"openai"` 的备选项。

**2. 在运行时选择备选项**
```python
# 默认情况，使用 default_key="anthropic"
chain.invoke({"topic": "bears"}) # -> 调用 ChatAnthropic

# 在调用时，通过 config 字典选择备选项
chain.with_config(
    configurable={"llm": "openai"}
).invoke({"topic": "bears"}) # -> 调用 ChatOpenAI()

chain.with_config(
    configurable={"llm": "gpt4"}
).invoke({"topic": "bears"}) # -> 调用 ChatOpenAI(model="gpt-4")
```
*   **`configurable={"llm": "openai"}`**: 我们使用槽位的 `id` (`"llm"`) 作为键，使用备选项的**键名** (`"openai"`) 作为值，来告诉 LangChain 在这次运行中进行替换。

#### 同时配置多个槽位

这个模式可以无限扩展。你可以让 `prompt` 和 `llm` 都变成可配置的，然后在一次调用中同时指定它们：
```python
chain.with_config(configurable={"prompt": "poem", "llm": "openai"}).invoke(...)
```
*   **效果**: 这次调用会使用 `"poem"` 版本的 Prompt，并将它发送给 `"openai"` 版本的 LLM。

#### 保存配置

你也可以将一个常用的配置组合，保存成一个新的 `Runnable` 对象，方便复用。
```python
openai_joke_chain = chain.with_config(configurable={"llm": "openai"})

# 之后就可以直接使用这个预设好的链
openai_joke_chain.invoke({"topic": "bears"})
```

### 总结

`configurable_fields` 和 `configurable_alternatives` 是 LangChain 提供的、用于构建**动态、可实验、可扩展**应用的终极武器。

| 方法 | 核心功能 | 比喻 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **`.configurable_fields`** | 动态**修改**组件的**参数** | 相机的“专业模式”，可调参数 | A/B 测试**参数**（如 `temperature`），让用户**微调**行为 |
| **`.configurable_alternatives`** | 动态**替换**整个**组件** | 相机的“可换镜头系统” | A/B 测试**整个组件**（如不同模型、不同 Prompt），多租户个性化，构建 AI Playground |

掌握了这两个方法，你就拥有了构建企业级、生产就绪的、能够适应复杂业务变化的 LangChain 应用的核心能力。