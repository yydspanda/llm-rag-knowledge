好的，我们来仔细讲解这份关于**如何将参数从一个步骤“直通（Passthrough）”到后续步骤**的 LangChain 官方文档。

这份指南聚焦于 LCEL 中一个极其重要、但初学者常常感到困惑的组件：`RunnablePassthrough`。掌握它，是构建任何非平凡（non-trivial）的、需要多路数据汇合的 RAG 链或 Agent 的**必备技能**。

---

### 核心问题：为什么我需要“直通”参数？

在一条简单的、线性的 LCEL 链中，数据像单行道一样流动：
`A | B | C`

这里存在一个巨大的限制：**`B` 只能看到 `A` 的输出，`C` 只能看到 `B` 的输出。** `C` 完全不知道 `A` 的输出是什么，更不知道整个链条最开始的输入是什么。

**但现实世界的需求要复杂得多。** 看看经典的 RAG 场景：
1.  **初始输入**: 用户的**问题 (question)**。
2.  **中间步骤**: 使用**问题**去调用**检索器 (retriever)**，得到**上下文 (context)**。
3.  **最后步骤**: 需要将**上下文 (context)** 和**原始的问题 (question)** 一起，喂给一个 Prompt。

看到了吗？最后一步的 `prompt`，它既需要上一步（检索器）的输出 `context`，也需要**第一步的原始输入 `question`**！如果用简单的 `retriever | prompt`，`prompt` 就永远拿不到原始的 `question` 了。

`RunnablePassthrough` 就是为了解决这个“**如何在数据流中保留和传递旧信息**”的核心问题而生的。

---

### `RunnablePassthrough` 的核心功能：一个“纯粹的复印机”

`RunnablePassthrough` 的工作极其简单，也极其纯粹：
> **无论我接收到什么输入，我都将它原封不动地、不加任何修改地作为输出。**

它就像一台完美的“复印机”。你给它一个数字，它输出一个数字。你给它一个字典，它输出一模一样的字典。它**不**做任何计算或转换。

---

### `RunnablePassthrough` 的黄金搭档：`RunnableParallel`

单独使用 `RunnablePassthrough` 几乎毫无意义。它的魔力，只有在和它的黄金搭档 `RunnableParallel`（通常以字典 `{}` 的语法糖形式出现）结合时，才能完全展现。

`RunnableParallel` 负责**构建结构**，而 `RunnablePassthrough` 负责**填充内容**。

---

### 示例一：简单演示

让我们来解剖第一个简单的例子，看看它们是如何协作的。

**代码**:
```python
from langchain_core.runnables import RunnableParallel, RunnablePassthrough

runnable = RunnableParallel(
    passed=RunnablePassthrough(),
    modified=lambda x: x["num"] + 1,
)

runnable.invoke({"num": 1})
# -> {'passed': {'num': 1}, 'modified': 2}
```

**工作流程详解**:
1.  **输入**: `invoke` 的输入是一个字典 `{"num": 1}`。
2.  **进入 `RunnableParallel`**: 这个字典被**同时**分发给了 `passed` 和 `modified` 两个分支。
3.  **`passed` 分支**:
    *   `RunnablePassthrough()` 接收到输入 `{"num": 1}`。
    *   作为一台“复印机”，它**原封不动地**输出了 `{"num": 1}`。
4.  **`modified` 分支**:
    *   `lambda x: x["num"] + 1` 这个函数接收到输入 `{"num": 1}`。
    *   它执行计算 `1 + 1`。
    *   它输出了结果 `2`。
5.  **结果汇合**: `RunnableParallel` 收集两个分支的输出，并用它们各自的键（`passed` 和 `modified`）作为标签，组装成最终的字典。

这个例子清晰地展示了 `RunnablePassthrough` 的作用：**在并行的数据流中，创建了一个保留原始输入的“直通”通道**。

---

### 示例二：经典的 RAG 链（这是最重要的部分）

现在，让我们应用这个模式来解决我们开头提出的那个真实问题。

**代码**:
```python
retrieval_chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | model
    | StrOutputParser()
)

retrieval_chain.invoke("where did harrison work?")
```

**目标**: 我们需要为 `prompt` 组件，构造一个形如 `{"context": ..., "question": ...}` 的字典。

**工作流程详解**:
1.  **输入**: `invoke` 的输入是一个**字符串**: `"where did harrison work?"`。

2.  **进入第一站 (`{...}`)**: 这个字典被 LCEL 自动转换成一个 `RunnableParallel`。
    *   输入字符串被**同时**分发给了 `context` 和 `question` 两个分支。

3.  **`context` 分支**:
    *   `retriever` 接收到输入字符串 `"where did harrison work?"`。
    *   它执行向量搜索。
    *   它输出一个 `Document` 列表作为结果。

4.  **`question` 分支**:
    *   `RunnablePassthrough()` 接收到输入字符串 `"where did harrison work?"`。
    *   作为一台“复印机”，它**原封不动地**输出了这个字符串。

5.  **结果汇合**: `RunnableParallel` 收集两个分支的输出，并用键作为标签进行组装。
    *   `context` 键的值是 `retriever` 输出的 `Document` 列表。
    *   `question` 键的值是 `RunnablePassthrough` 输出的原始字符串。
    *   最终，这一站的输出是一个**全新的字典**:
        ```python
        {
            "context": [Document(page_content='harrison worked at kensho')],
            "question": "where did harrison work?"
        }
        ```

6.  **进入第二站 (`prompt`)**:
    *   `prompt` 接收到上一步构造好的、结构完美的字典。
    *   它成功地将 `{context}` 和 `{question}` 两个占位符都填充好，生成一个 `PromptValue`。

7.  **后续流程**: `PromptValue` 被传递给 `model`，`model` 的输出再被 `StrOutputParser` 解析，一切都顺理成章。

### 总结

`RunnablePassthrough` 是 LCEL 中用于**构建复杂数据流**的“粘合剂”。它的核心应用场景，永远是和 `RunnableParallel` (字典) 配合：

> **当你需要在一个链条的后续步骤中，使用一个在之前步骤中就已经存在（甚至是最初始的）的数据时，你就可以使用 `RunnableParallel` 来“分叉”出一个数据通道，并用 `RunnablePassthrough` 在这个通道中“原样保留”那份你需要的数据。**

掌握了这个模式，你就掌握了如何构建几乎所有 RAG 应用的核心数据流。