
### 核心问题：如果我有多个不同的知识库，怎么办？

在之前的教程中，我们都假设只有一个知识库（一个 `retriever`）。但现实世界中，信息往往是分散在不同地方的：
*   一个公司可能有**产品文档数据库**、**销售 CRM 数据库**和**HR 员工手册数据库**。
*   一个个人助手可能需要查询**日历**、**邮件**和**本地笔记**。

当用户提问时，比如“下周二我和谁有会议？”，一个智能系统不应该去搜索产品文档，而应该**直接去查询日历**。

这份文档的核心就是教我们如何构建一个能够**根据用户问题，智能地选择使用哪个特定知识库（retriever）**的 RAG 系统。这个过程我们称之为**检索路由（Retrieval Routing）**。

---

### 1. 准备工作：创建多个独立的知识库

为了模拟这个场景，文档创建了两个完全独立的向量数据库，每个数据库只包含一个人的信息。

**代码讲解**:
```python
# 知识库 1: 只关于 Harrison
texts = ["Harrison worked at Kensho"]
vectorstore_harrison = Chroma.from_texts(texts, embeddings, collection_name="harrison")
retriever_harrison = vectorstore_harrison.as_retriever()

# 知识库 2: 只关于 Ankush
texts = ["Ankush worked at Facebook"]
vectorstore_ankush = Chroma.from_texts(texts, embeddings, collection_name="ankush")
retriever_ankush = vectorstore_ankush.as_retriever()
```
*   **关键点**: `collection_name="harrison"` 和 `collection_name="ankush"`。在 ChromaDB 中，`collection` 就像数据库中的一张独立的表。通过指定不同的 `collection_name`，我们确保了这两个知识库在物理上是隔离的。
*   现在我们有了 `retriever_harrison` 和 `retriever_ankush`，它们分别代表两个**专用的、互不干扰**的“信息专家”。

---

### 2. 查询分析：构建“智能调度员” (The Router)

和之前的教程一样，核心在于“查询分析”这一步。但这次，分析器的任务不再是“是否要搜索”或“要搜几个”，而是“**应该派哪个专家（retriever）去执行任务**”。我们称之为“调度员”或“路由器”。

**步骤 2.1: 定义一个包含“路由信息”的动作**

```python
class Search(BaseModel):
    """Search for information about a person."""
    query: str = Field(..., description="Query to look up")
    person: str = Field(..., description="Person to look things up for. Should be `HARRISON` or `ANKUSH`.")
```
*   **讲解 (与之前教程的关键对比)**:
    *   这个 `Search` 模型现在包含了**两个字段**。
    *   `query: str`: 这和之前一样，是**“做什么（What）”**，即具体的搜索内容。
    *   `person: str`: 这是新增的、最关键的字段，它代表**“派谁去（Who）”**，也就是我们的**路由信息**。
    *   `description="...Should be 'HARRISON' or 'ANKUSH'."`: 这是一个非常重要的**提示工程技巧**。我们直接在 Pydantic 模型的描述中，明确地告诉 LLM 这个字段的**合法取值**。这极大地约束和引导了 LLM，使其输出我们期望的、可控的结果。

**步骤 2.2: 指导 LLM 成为“调度员”**

```python
system = """You have the ability to issue search queries..."""
# ...
structured_llm = llm.with_structured_output(Search) # 强制输出 Search 结构
query_analyzer = {"question": RunnablePassthrough()} | prompt | structured_llm
```
*   **讲解**: 我们使用 `with_structured_output(Search)` 来**强制** LLM 的输出必须符合我们定义的 `Search` 格式。这意味着，LLM 在接收到用户问题后，必须给出一个包含 `query` 和 `person` 两个字段的答案。它被迫要去思考这个问题到底是关于谁的。

**步骤 2.3: 观察“调度员”的行为**

*   **当用户问及 Harrison**:
    ```python
    query_analyzer.invoke("where did Harrison Work")
    ```
    **输出**: `Search(query='work history', person='HARRISON')`
    *   **分析**: 模型成功完成了两件事：
        1.  **改写查询 (What)**: 将口语化的 `"where did Harrison Work"` 改写成了更适合检索的 `"work history"`。
        2.  **确定路由 (Who)**: 准确地将 `person` 字段设置为 `'HARRISON'`。

*   **当用户问及 Ankush**:
    ```python
    query_analyzer.invoke("where did ankush Work")
    ```
    **输出**: `Search(query='work history', person='ANKUSH')`
    *   **分析**: 同样，模型准确地将 `person` 字段设置为 `'ANKUSH'`。

至此，我们已经成功创建了一个能够根据用户问题，输出“任务内容”和“执行者”的智能调度员。

---

### 3. 整合：执行路由决策

现在我们有了“调度员”的指令，最后一步就是根据这个指令，去调用正确的“专家”。

**代码讲解**:
```python
from langchain_core.runnables import chain

# 步骤 A: 创建一个“专家名录”（调度表）
retrievers = {
    "HARRISON": retriever_harrison,
    "ANKUSH": retriever_ankush,
}

@chain
def custom_chain(question):
    # 步骤 B: 调用“调度员”获取指令
    response = query_analyzer.invoke(question)
    
    # 步骤 C: 根据指令，从名录中查找并选择正确的专家
    retriever = retrievers[response.person]
    
    # 步骤 D: 让选中的专家执行任务
    return retriever.invoke(response.query)
```
*   **`retrievers = {...}`**: 这是一个 Python 字典，我们称之为**调度表**或**路由表**。它的作用是建立一个从**字符串标识符**（LLM 输出的 `'HARRISON'`）到**实际 Python 对象**（我们之前创建的 `retriever_harrison`）的映射。这是连接 AI 决策和代码执行的桥梁。

*   **`custom_chain` 函数的逻辑**:
    1.  `response = query_analyzer.invoke(question)`: 调用“调度员”，得到一个 `Search` 对象，里面包含了 `query` 和 `person`。
    2.  `retriever = retrievers[response.person]`: 这是整个路由逻辑的**核心**。
        *   我们从 `response` 中取出 `person` 字段的值（比如 `'HARRISON'`）。
        *   我们用这个值作为 `key`，在 `retrievers` 字典中进行查找。
        *   `retrievers['HARRISON']` 返回的正是 `retriever_harrison` 这个对象。`retriever` 变量现在就指向了正确的“专家”。
    3.  `return retriever.invoke(response.query)`: 我们使用上一步选出的 `retriever`，并把 `response` 中的 `query` 字段（`'work history'`）作为参数传给它，执行最终的检索。

### 总结

这份文档向我们展示了一个极其强大和通用的**路由模式**，可以总结为三步：

1.  **定义路由目标**: 准备多个专用的组件（在这里是多个 `retriever`）。
2.  **决策 (Decide)**: 设计一个 Pydantic 模型，其中包含一个用于**路由**的字段（如 `person`），并让 LLM 输出这个模型。LLM 的角色是“智能调度员”。
3.  **执行 (Execute)**: 在代码中创建一个调度表（如 `retrievers` 字典），根据 LLM 在路由字段中返回的值，选择并执行相应的组件。

这个模式的应用远不止于多个 `retriever`。您可以将它扩展到：
*   **多工具选择**: `person` 字段可以换成 `tool_name`，值可以是 `'web_search'`, `'sql_query'`, `'calculator'` 等，从而让 LLM 决定使用哪个工具。
*   **多文档类型处理**: `person` 字段可以换成 `document_type`，值可以是 `'PDF'`, `'Email'`, `'Website'`，从而调用不同的文档处理链。

掌握了这个模式，您就掌握了构建更复杂、更智能、能够与多个系统交互的 AI Agent 的基础。