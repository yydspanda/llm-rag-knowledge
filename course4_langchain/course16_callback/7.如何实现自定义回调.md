## 基础介绍

**自定义事件 (Custom Events)** 的是 LangChain 回调系统中最具扩展性和创造性的部分。它让你能够超越 LangChain 预设的事件（如 `on_llm_start`），创建属于你自己的、完全定制的事件信号。

### 核心思想：从“被动监听”到“主动广播”

之前我们接触的所有回调事件（`on_llm_start`, `on_chain_start` 等）都是 LangChain 框架在执行其内置组件时**被动触发**的。你只能监听，不能决定何时触发。

自定义事件则让你反客为主。在你自己创建的 `Runnable`（例如，一个 `RunnableLambda` 或者自定义类）的逻辑中，你可以**主动地广播 (broadcast) 或分发 (dispatch)** 一个你自定义的信号。

**比喻一下：**
*   **标准事件**: 就像公共广播电台（FM 98.1, AM 1024）。电台（LangChain 框架）决定何时播放什么节目（`on_llm_start` 事件），你只能打开收音机（Callback Handler）去听。
*   **自定义事件**: 就像给你一个对讲机。你（你的自定义代码）可以在任何你认为重要的时刻，按下通话按钮，**主动喊话**（`dispatch_custom_event`），而任何持有相同频道对讲机的人（你的 Callback Handler）都能听到你的喊话内容。

### 为什么需要自定义事件？

当你构建复杂的、包含自定义业务逻辑的 Chain 时，你可能想在一些对你很重要的、但 LangChain 框架并不知道的节点上获得通知。

*   **业务逻辑里程碑**: “用户身份验证成功”、“已从数据库成功获取数据”、“数据验证步骤开始”等。
*   **调试复杂组件**: 在一个复杂的自定义 `Runnable` 的多个计算步骤之间，广播中间结果或状态。
*   **精细化的 UI 更新**: 向前端发送非常具体的状态更新，比如 “正在分析文本情绪...”、“正在生成摘要...” 等，而不仅仅是泛泛的 “Chain 已开始”。

### 实现自定义事件的两个关键部分

1.  **分发事件 (Dispatching)**: 在你的 `Runnable` 内部，使用 `langchain_core.callbacks.dispatch_custom_event` 函数来广播事件。
2.  **监听事件 (Listening)**: 在你的自定义 `Callback Handler` 中，实现 `on_custom_event` 方法来接收这些广播。

---

### 代码 Demo 深度讲解

让我们一步步分解文档中的例子，看看这个“对讲机”系统是如何工作的。

#### 第 1 步：创建能听到“喊话”的 Handler

首先，我们需要一个能接收自定义事件的 Callback Handler。关键在于实现 `on_custom_event` 方法。

```python
from typing import Any, Dict, List
from uuid import UUID

from langchain.callbacks.base import BaseCallbackHandler

class MyCustomHandler(BaseCallbackHandler):
    """一个能监听自定义事件的 Handler。"""

    def on_custom_event(
        self,
        name: str,          # 事件的名称，也就是“喊话”的频道名
        data: Dict[str, Any], # 事件附带的数据，也就是“喊话”的内容
        **kwargs: Any,
    ) -> None:
        """当一个自定义事件被分发时，这个方法会被调用。"""
        print(f"--- Received Custom Event ---")
        print(f"Event Name: {name}")
        print(f"Event Data: {data}")
        print(f"-----------------------------")

        # 你可以根据事件名称执行不同的逻辑
        if name == "add_one_started":
            print(f"Logic for 'add_one_started': The input was {data.get('input')}")
        elif name == "multiply_by_two_started":
            print(f"Logic for 'multiply_by_two_started': About to multiply {data.get('input')}")
```

**代码讲解**:

*   `on_custom_event(self, name: str, data: Dict[str, Any], ...)`: 这是唯一的、用于捕获**所有**自定义事件的方法。
*   `name: str`: 这个参数至关重要。它就是你用来区分不同自定义事件的标识符。你的 `Handler` 会用 `if/elif/else` 结构来根据 `name` 决定执行什么逻辑。
*   `data: Dict[str, Any]`: 这是一个字典，用于传递与事件相关的任意上下文数据。

#### 第 2 步：创建会“主动喊话”的 Chain

现在，我们来构建一个 Chain。这个 Chain 包含两个自定义步骤，每个步骤在执行自己的核心逻辑之前，都会用 `dispatch_custom_event` 来“喊一嗓子”。

```python
from langchain_core.callbacks import dispatch_custom_event
from langchain_core.runnables import RunnableLambda

# 创建一个 Handler 实例
handler = MyCustomHandler()

# --- 第一个自定义步骤：加一 ---
def add_one(x: int) -> int:
    # 在执行核心逻辑前，分发一个事件
    # name='add_one_started', data={'input': x}
    dispatch_custom_event("add_one_started", {"input": x})
    return x + 1

add_one_runnable = RunnableLambda(add_one)


# --- 第二个自定义步骤：乘以二 ---
def multiply_by_two(x: int) -> int:
    # 在执行核心逻辑前，分发另一个事件
    dispatch_custom_event("multiply_by_two_started", {"input": x})
    return x * 2

multiply_by_two_runnable = RunnableLambda(multiply_by_two)


# --- 将这两个步骤组合成一个 Chain ---
chain = add_one_runnable | multiply_by_two_runnable
```

**代码讲解**:

*   `from langchain_core.callbacks import dispatch_custom_event`: 导入“喊话”工具。
*   `dispatch_custom_event("add_one_started", {"input": x})`: 这是魔法发生的地方。
    *   **第一个参数 `"add_one_started"`**: 这是事件的**名称**。我们的 Handler 会在 `on_custom_event` 方法中接收到这个字符串。
    *   **第二个参数 `{"input": x}`**: 这是事件的**数据负载 (payload)**。我们把当前的输入 `x` 打包进去，这样监听者就能知道事件发生时的上下文。
*   `RunnableLambda(...)`: 我们用 `RunnableLambda` 将普通的 Python 函数包装成 LangChain 生态系统中的标准组件，这样它们才能被链接（`|`），并获得回调系统的支持。

#### 第 3 步：运行并观察魔法的发生

现在，我们用一个请求来调用这个 Chain，并通过 `config` 传入我们的自定义 Handler。

```python
# 调用 chain，并附加上我们的 handler
result = chain.invoke(1, config={"callbacks": [handler]})

print("\nFinal Result:", result)
```

#### 输出分析

当你运行这段代码，你会看到以下输出，它清晰地展示了整个流程：

```
--- Received Custom Event ---
Event Name: add_one_started
Event Data: {'input': 1}
-----------------------------
Logic for 'add_one_started': The input was 1

--- Received Custom Event ---
Event Name: multiply_by_two_started
Event Data: {'input': 2}
-----------------------------
Logic for 'multiply_by_two_started': About to multiply 2

Final Result: 4
```

**发生了什么？**

1.  `chain.invoke(1, ...)` 开始执行。
2.  第一个组件 `add_one_runnable` 被调用，输入是 `1`。
3.  在 `add_one` 函数内部，`dispatch_custom_event("add_one_started", {"input": 1})` 被执行。
4.  附加的 `MyCustomHandler` 立即“听到”了这个事件，它的 `on_custom_event` 方法被触发，打印出了第一个事件块的信息。
5.  `add_one` 函数返回 `2`。
6.  这个结果 `2` 被传递给第二个组件 `multiply_by_two_runnable`。
7.  在 `multiply_by_two` 函数内部，`dispatch_custom_event("multiply_by_two_started", {"input": 2})` 被执行。
8.  `MyCustomHandler` 再次被触发，打印出第二个事件块的信息。
9.  `multiply_by_two` 函数返回 `4`。
10. `invoke` 调用结束，最终结果 `4` 被打印出来。

### 总结

自定义事件机制是你工具箱里的一个高级工具，它将 LangChain 的回调系统从一个只能观察标准流程的系统，变成了一个可以与你自己的业务逻辑深度集成的、完全可编程的事件总线。通过“分发”和“监听”，你可以让你的 Chain 在运行时“讲述”一个更丰富、更具体的故事。


## 深入讲解

### 方法一：使用 astream_events (最推荐的异步方法)
这是消费事件最现代、最直接的方法。您可以像处理数据流一样处理所有事件。当你调用一个链的 .astream_events(..., version="v2") 方法时，它会源源不断地返回执行过程中的所有事件，包括链的开始、结束、中间的流式输出，以及您自己发送的自定义事件。

优点：非常简单直观，能在一个地方接收所有类型的事件。

注意：必须使用异步环境，并且明确指定 version="v2"，python version >= 3.10。

```python
from langchain_core.callbacks.manager import (
    adispatch_custom_event,
)
from langchain_core.runnables import RunnableLambda
from langchain_core.runnables.config import RunnableConfig

# 装饰器，将普通 Python 函数变成 LangChain 的可运行组件
@RunnableLambda
async def foo(x: str) -> str:
    # 异步分发一个名为 "event1" 的事件，数据是 {"x": "hello world"}
    await adispatch_custom_event("event1", {"x": x})
    # 异步分发一个名为 "event2" 的事件，数据是整数 5
    await adispatch_custom_event("event2", 5)
    return x

# 调用 foo，并监听其执行过程中产生的所有事件
async for event in foo.astream_events("hello world", version="v2"):
    print(event)
```

- 讲解:
1. @RunnableLambda: 这是一个方便的装饰器，它能立刻将一个函数（这里是 foo）包装成一个 LangChain 的可运行对象 (Runnable)。这样 foo 就拥有了 .invoke(), .stream(), .astream_events() 等标准方法。
2. async def foo(x: str): 这是一个简单的异步函数，它接受一个字符串 x。
3. await adispatch_custom_event(...): 这是代码的核心。这个函数的作用是“广播”或“发出”一个自定义事件。你可以把它想象成在代码执行过程中，举起一个牌子说：“嘿，我到这一步了！这是我的状态！”。
4. async for event in foo.astream_events(...): 这里是事件的消费者。.astream_events() 会启动 foo 函数，并像一个事件监听器一样，捕获 foo 在运行期间发出的所有事件，包括 LangChain 自己产生的标准事件（如任务开始、结束）和我们用 adispatch_custom_event 发出的自定义事件。
5. 关键点 (自动传播): 在 Python 3.11+ 中，LangChain 可以自动将运行时的上下文（包括用于监听事件的回调管理器）“注入”到 adispatch_custom_event 函数中。因此，你不需要在 foo 函数的定义里写任何关于 config 的东西，一切都会在后台自动处理。这使得代码非常简洁。

```python
from langchain_core.callbacks.manager import (
    adispatch_custom_event,
)
from langchain_core.runnables import RunnableLambda
from langchain_core.runnables.config import RunnableConfig

@RunnableLambda
async def bar(x: str, config: RunnableConfig) -> str:
    """一个展示如何手动传播配置的例子。
    如果你使用的 Python 版本 <= 3.10，则必须这样做。
    """
    # 分发事件时，必须显式地将 config 对象传递进去
    await adispatch_custom_event("event1", {"x": x}, config=config)
    await adispatch_custom_event("event2", 5, config=config)
    return x

# 调用方式和打印逻辑与第一个例子完全相同
async for event in bar.astream_events("hello world", version="v2"):
    print(event)
```
讲解:

这段代码的功能和第一段完全一样，但实现方式略有不同。

1. async def bar(x: str, config: RunnableConfig): 注意看函数签名，这里多了一个参数 config: RunnableConfig。RunnableConfig 对象包含了当前这一次运行的所有上下文信息，比如运行 ID、标签（tags），以及最重要的——回调处理器（Callback Handlers），也就是事件的监听器。
2. await adispatch_custom_event(..., config=config): 在调用 adispatch_custom_event 时，我们必须手动将这个 config 对象传进去。
3. 关键点 (手动传播): 在 Python 3.10 及更早版本中，这种运行时的上下文无法自动传递给异步任务。因此，你必须：
    - 在函数定义中明确地接收 config 对象。
    - 在需要用到这个上下文的地方（比如分发事件时），再明确地把它传递下去。
    - 如果不这样做，adispatch_custom_event 就会像是在一个“真空”环境中被调用，它不知道应该把事件发送给哪个监听器，最终导致你在 astream_events 里接收不到任何自定义事件。

### 方法二：使用自定义回调处理器 (Callback Handler)

这是一种更传统、也更灵活的方法。您需要创建一个自己的类，并继承 LangChain 提供的 BaseCallbackHandler (同步) 或 AsyncCallbackHandler (异步)。

在这个类里，您需要实现一个特定的方法，叫做 on_custom_event。

当您的链在执行过程中发送了一个自定义事件时，LangChain 框架会自动调用您这个处理器类中的 on_custom_event 方法，并将事件的名称和数据传递给它。您就可以在这个方法里编写处理逻辑，比如把事件内容打印出来、存到数据库或者通过 WebSocket 发送给前端。

```python
from typing import Any, Dict, List, Optional
from uuid import UUID

from langchain_core.callbacks import AsyncCallbackHandler
from langchain_core.callbacks.manager import (
    adispatch_custom_event,
)
from langchain_core.runnables import RunnableLambda
from langchain_core.runnables.config import RunnableConfig


class AsyncCustomCallbackHandler(AsyncCallbackHandler):
    async def on_custom_event(
        self,
        name: str,
        data: Any,
        *,
        run_id: UUID,
        tags: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        **kwargs: Any,
    ) -> None:
        print(
            f"Received event {name} with data: {data}, with tags: {tags}, with metadata: {metadata} and run_id: {run_id}"
        )


@RunnableLambda
async def bar(x: str, config: RunnableConfig) -> str:
    """An example that shows how to manually propagate config.

    You must do this if you're running python<=3.10.
    """
    await adispatch_custom_event("event1", {"x": x}, config=config)
    await adispatch_custom_event("event2", 5, config=config)
    return x


async_handler = AsyncCustomCallbackHandler()
await foo.ainvoke(1, {"callbacks": [async_handler], "tags": ["foo", "bar"]})
```

下面是同步调用的方式：

```python
from typing import Any, Dict, List, Optional
from uuid import UUID

from langchain_core.callbacks import BaseCallbackHandler
from langchain_core.callbacks.manager import (
    dispatch_custom_event,
)
from langchain_core.runnables import RunnableLambda
from langchain_core.runnables.config import RunnableConfig


class CustomHandler(BaseCallbackHandler):
    def on_custom_event(
        self,
        name: str,
        data: Any,
        *,
        run_id: UUID,
        tags: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        **kwargs: Any,
    ) -> None:
        print(
            f"Received event {name} with data: {data}, with tags: {tags}, with metadata: {metadata} and run_id: {run_id}"
        )


@RunnableLambda
def foo(x: int, config: RunnableConfig) -> int:
    dispatch_custom_event("event1", {"x": x})
    dispatch_custom_event("event2", {"x": x})
    return x


handler = CustomHandler()
foo.invoke(1, {"callbacks": [handler], "tags": ["foo", "bar"]})
```